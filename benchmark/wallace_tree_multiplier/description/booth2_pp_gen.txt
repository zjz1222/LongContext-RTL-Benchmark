Module name:  
    booth2_pp_gen  

Function description:  
    This module generates eight partial product operands for a 16x16 multiplier using the Radix-4 Booth encoding algorithm. It takes the multiplicand and multiplier as inputs and outputs eight 18-bit partial products. These partial products correspond to weighted multiples of the multiplicand based on 3-bit overlapping slices of the multiplier and include handling of negative multiples using a specialized inverse converter circuit.

Input ports:  
    A_NUM [15:0]: 16-bit multiplicand input.  
    B_NUM [15:0]: 16-bit multiplier input.  

Output ports:  
    PP1, PP2, PP3, PP4, PP5, PP6, PP7, PP8 [17:0]: Eight 18-bit partial product outputs generated from the Booth encoded slices of the multiplier. Each partial product is 18 bits wide to accommodate sign representation for negative multiples.

Implementation:  
    - The multiplier (B_NUM) is divided into overlapping groups of bits to generate Booth codes used for partial product calculation. Specifically:  
      - B_code1 uses 2 bits (B_NUM[1:0]) for the first partial product.  
      - B_code2 to B_code8 use 3 bits (e.g., B_NUM[3:1], B_NUM[5:3], etc.) for the subsequent partial products.  

    - An auxiliary module `inv_converter_16` is instantiated to compute the two's complement (negation) of the multiplicand (A_NUM), producing `inversed_A`. This is used to efficiently generate negative multiples without employing adders, thus saving hardware resources.  

    - The first partial product (PP1) is generated by a simplified Booth decoder module `booth2_pp_decoder_pp1` which takes the 2-bit Booth code and produces the partial product. This simplification is possible because the lowest Booth code's least significant bit is always zero.  

    - The remaining partial products (PP2 to PP8) are generated by instantiating the full `booth2_pp_decoder` module for each 3-bit Booth code slice. Each decoder takes the Booth code, the original multiplicand (A_NUM), and its negation (inversed_A), and outputs the corresponding 18-bit partial product.  

    - The width of each partial product is 18 bits, wider than the multiplicand width, because partial products representing -2¡ÁA require a sign bit (PP[17]) for correct sign representation.  

    - This modular approach, combining inverse conversion and Booth decoders, efficiently produces all partial products needed for Radix-4 Booth multiplication while minimizing hardware resource usage as described in the header comments.

Submodules:
    - inv_converter_16  
    Input ports:  
        data_i [15:0]: A 16-bit two's complement input data to be negated.
    Output ports:  
        inv_o [16:0]: A 17-bit two's complement output that represents the negation of the input data. The extra bit handles the sign extension for corner cases.
    Functionality:  
        This module converts a 16-bit two's complement input number into its corresponding negation in two's complement form. Essentially, it computes the two's complement of the input by performing a bitwise inversion and then adding one. The output is a 17-bit signed number to accommodate the potential overflow case (e.g., the negation of 16'h8000 requires 17 bits).
    
    - booth2_pp_decoder_pp1
    Input ports:  
        code_2bit [1:0]: A 2-bit Booth code input, representing {b1, b0} bits of the Booth encoding used to determine the multiplication factor for the current partial product. The lowest bit b-1 is always zero and thus omitted.  
        A [15:0]: The 16-bit multiplicand input.  
        inversed_A [16:0]: The 17-bit inverted multiplicand (-A), provided to simplify the circuit for producing negative multiples.
    Output ports:  
        pp_out [17:0]: An 18-bit output which is the generated partial product based on the Booth code and inputs. The width accommodates results such as -2 * 16'h8000 which requires 18 bits.
    Functionality:  
        This module is a dedicated decoder for generating the first partial product (pp1) in a Booth multiplication algorithm implementation. It processes a 2-bit simplified Booth code (since the least significant bit of the original 3-bit Booth code is always zero for the first partial product) along with the multiplicand A and its inverted form (-A) to produce an 18-bit partial product output. The module handles generating the partial product corresponding to the inputs according to the Booth encoding rules and optimizes the logic circuit usage.
    
    - booth2_pp_decoder
    Functionality:  
        This module implements a Booth radix-4 partial product decoder. It takes a 3-bit Booth-encoded input `code` and a 16-bit multiplicand `A` along with its 17-bit bitwise inversion `inversed_A` (representing -A), and outputs an 18-bit partial product (`pp_out`). The output partial product is provided in an inverted logic form, with the highest bit being the inverted sign bit, to facilitate subsequent signed arithmetic operations in multiplication.
    Input ports:  
        code [2:0]: The 3-bit Booth encoded multiplier bits representing the current partial product encoding for Radix-4 Booth multiplication.  
        A [15:0]: The original multiplicand input.  
        inversed_A [16:0]: The bitwise inverted version of multiplicand `A` extended to 17 bits, representing -A in two's complement format.
    Output ports:  
        pp_out [17:0]: The 18-bit partial product output generated according to the Booth encoding. The output is in inverted logic form, especially the most significant bit which is inverted to simplify sign handling in multiplication.
    